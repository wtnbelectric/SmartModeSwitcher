<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/smartmodeswitcher/ui/DashboardFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/smartmodeswitcher/ui/DashboardFragment.kt" />
              <option name="originalContent" value="package com.example.smartmodeswitcher.ui&#10;&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.smartmodeswitcher.R&#10;import com.example.smartmodeswitcher.data.AppDatabase&#10;import com.example.smartmodeswitcher.data.RuleRepository&#10;import com.google.android.material.datepicker.MaterialDatePicker&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.time.Instant&#10;import java.time.ZoneId&#10;import com.example.smartmodeswitcher.ui.DashboardViewModel&#10;import com.example.smartmodeswitcher.ui.RuleAdapter&#10;import java.time.LocalDate&#10;import android.widget.FrameLayout&#10;import android.util.TypedValue&#10;import android.graphics.Color&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.GeofencingClient&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofencingRequest&#10;&#10;import com.example.smartmodeswitcher.receiver.GeofenceBroadcastReceiver&#10;&#10;class DashboardFragment : Fragment() {&#10;    private var selectedDate: Long = MaterialDatePicker.todayInUtcMilliseconds()&#10;&#10;    // DB, Repository, Factoryの初期化&#10;    private val db by lazy { AppDatabase.getInstance(requireContext().applicationContext) }&#10;    private val repository by lazy { RuleRepository(db.ruleDao()) }&#10;    private val factory by lazy { DashboardViewModelFactory(repository) }&#10;    private val viewModel: DashboardViewModel by viewModels { factory }&#10;&#10;    private lateinit var ganttChartView: GanttChartView&#10;    private lateinit var geofencingClient: GeofencingClient&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?&#10;    ): View? {&#10;        val root = inflater.inflate(R.layout.fragment_dashboard, container, false)&#10;        val buttonPickDate = root.findViewById&lt;Button&gt;(R.id.buttonPickDate)&#10;        val textSelectedDate = root.findViewById&lt;TextView&gt;(R.id.textSelectedDate)&#10;&#10;        // RecyclerViewとアダプタのセット&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.recyclerViewRules)&#10;        val adapter = RuleAdapter { rule, isEnabled -&gt;&#10;            // 有効/無効変更時にDBへ反映&#10;            val updatedRule = rule.copy(enabled = isEnabled)&#10;            viewModel.updateRule(updatedRule)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = androidx.recyclerview.widget.LinearLayoutManager(requireContext())&#10;&#10;        // ガントチャートViewのセットアップ&#10;        val ganttContainer = root.findViewById&lt;FrameLayout&gt;(R.id.ganttChartContainer)&#10;        ganttChartView = GanttChartView(requireContext())&#10;        ganttContainer.addView(ganttChartView, FrameLayout.LayoutParams(&#10;            FrameLayout.LayoutParams.MATCH_PARENT,&#10;            FrameLayout.LayoutParams.MATCH_PARENT&#10;        ))&#10;&#10;        // LiveData監視&#10;        viewModel.rules.observe(viewLifecycleOwner) { rules -&gt;&#10;            adapter.submitList(rules)&#10;            // ガントチャートにも反映&#10;            ganttChartView.setRules(rules)&#10;            // Geofenceリストの作成&#10;            val geofenceList = createGeofenceList(rules)&#10;            android.util.Log.d(&quot;DashboardFragment&quot;, &quot;Geofenceリスト作成: ${geofenceList.size}件&quot;)&#10;&#10;            // Geofence登録&#10;            if (geofenceList.isNotEmpty()) {&#10;                val geofencingRequest = createGeofencingRequest(geofenceList)&#10;                val pendingIntent = getGeofencePendingIntent()&#10;                geofencingClient.addGeofences(geofencingRequest, pendingIntent)&#10;                    .addOnSuccessListener {&#10;                        android.util.Log.d(&quot;DashboardFragment&quot;, &quot;Geofence登録成功&quot;)&#10;                    }&#10;                    .addOnFailureListener { e -&gt;&#10;                        android.util.Log.e(&quot;DashboardFragment&quot;, &quot;Geofence登録失敗: ${e.message}&quot;)&#10;                    }&#10;            }&#10;        }&#10;&#10;        // 初期表示時に現在の日付でルールを読み込む&#10;        val currentDate = LocalDate.now()&#10;        textSelectedDate.text = formatDate(selectedDate)&#10;        viewModel.loadRulesForDate(currentDate)&#10;&#10;        // 2. 日付選択ボタンのリスナー&#10;        buttonPickDate.setOnClickListener {&#10;            val picker = MaterialDatePicker.Builder.datePicker()&#10;                .setTitleText(&quot;日付を選択&quot;)&#10;                .setSelection(selectedDate)&#10;                .build()&#10;            picker.addOnPositiveButtonClickListener { dateMillis -&gt;&#10;                selectedDate = dateMillis&#10;                textSelectedDate.text = formatDate(selectedDate)&#10;                // 3. 日付選択後のViewModel呼び出し&#10;                val localDate = Instant.ofEpochMilli(selectedDate)&#10;                    .atZone(ZoneId.systemDefault())&#10;                    .toLocalDate()&#10;                viewModel.loadRulesForDate(localDate)&#10;            }&#10;            picker.show(parentFragmentManager, &quot;date_picker&quot;)&#10;        }&#10;&#10;        geofencingClient = LocationServices.getGeofencingClient(requireContext())&#10;&#10;        return root&#10;    }&#10;&#10;    private fun formatDate(millis: Long): String {&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;        return sdf.format(Date(millis))&#10;    }&#10;&#10;    /**&#10;     * MainActivityから呼ばれる: ジオフェンスや位置情報イベントで有効になったルールIDを受け取りUIに反映&#10;     */&#10;    fun handleRuleSearchResult(ruleId: Long?) {&#10;        // 例: 現在有効なルールIDをViewModelやローカル変数にセットし、ガントチャートやリストをハイライト&#10;        // 必要に応じてadapterやViewModelに通知&#10;        // ここではログ出力のみ&#10;        android.util.Log.d(&quot;DashboardFragment&quot;, &quot;handleRuleSearchResult: ruleId=$ruleId&quot;)&#10;        // TODO: UIハイライトや状態更新処理をここに実装&#10;    }&#10;&#10;    /**&#10;     * 位置情報付きルールからGeofenceリストを作成&#10;     */&#10;    private fun createGeofenceList(rules: List&lt;com.example.smartmodeswitcher.data.Rule&gt;): List&lt;Geofence&gt; {&#10;        return rules.filter { it.latitude != null &amp;&amp; it.longitude != null &amp;&amp; it.radius != null }&#10;            .map { rule -&gt;&#10;                Geofence.Builder()&#10;                    .setRequestId(&quot;rule_${rule.id}&quot;)&#10;                    .setCircularRegion(&#10;                        rule.latitude!!,&#10;                        rule.longitude!!,&#10;                        rule.radius!!.toFloat()&#10;                    )&#10;                    .setExpirationDuration(Geofence.NEVER_EXPIRE)&#10;                    .setTransitionTypes(&#10;                        Geofence.GEOFENCE_TRANSITION_ENTER or Geofence.GEOFENCE_TRANSITION_EXIT&#10;                    )&#10;                    .build()&#10;            }&#10;    }&#10;&#10;    /**&#10;     * GeofenceリストからGeofencingRequestを作成&#10;     */&#10;    private fun createGeofencingRequest(geofenceList: List&lt;Geofence&gt;): GeofencingRequest {&#10;        return GeofencingRequest.Builder()&#10;            .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)&#10;            .apply {&#10;                geofenceList.forEach { addGeofence(it) }&#10;            }&#10;            .build()&#10;    }&#10;&#10;    private fun getGeofencePendingIntent(): PendingIntent {&#10;        val intent = Intent(requireContext(), GeofenceBroadcastReceiver::class.java)&#10;        return PendingIntent.getBroadcast(&#10;            requireContext(),&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.smartmodeswitcher.ui&#10;&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.smartmodeswitcher.R&#10;import com.example.smartmodeswitcher.data.AppDatabase&#10;import com.example.smartmodeswitcher.data.RuleRepository&#10;import com.google.android.material.datepicker.MaterialDatePicker&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.time.Instant&#10;import java.time.ZoneId&#10;import com.example.smartmodeswitcher.ui.DashboardViewModel&#10;import com.example.smartmodeswitcher.ui.RuleAdapter&#10;import java.time.LocalDate&#10;import android.widget.FrameLayout&#10;import android.util.TypedValue&#10;import android.graphics.Color&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.GeofencingClient&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofencingRequest&#10;&#10;import com.example.smartmodeswitcher.receiver.GeofenceBroadcastReceiver&#10;&#10;class DashboardFragment : Fragment() {&#10;    private var selectedDate: Long = MaterialDatePicker.todayInUtcMilliseconds()&#10;&#10;    // DB, Repository, Factoryの初期化&#10;    private val db by lazy { AppDatabase.getInstance(requireContext().applicationContext) }&#10;    private val repository by lazy { RuleRepository(db.ruleDao()) }&#10;    private val factory by lazy { DashboardViewModelFactory(repository) }&#10;    private val viewModel: DashboardViewModel by viewModels { factory }&#10;&#10;    private lateinit var ganttChartView: GanttChartView&#10;    private lateinit var geofencingClient: GeofencingClient&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?&#10;    ): View? {&#10;        val root = inflater.inflate(R.layout.fragment_dashboard, container, false)&#10;        val buttonPickDate = root.findViewById&lt;Button&gt;(R.id.buttonPickDate)&#10;        val textSelectedDate = root.findViewById&lt;TextView&gt;(R.id.textSelectedDate)&#10;&#10;        // RecyclerViewとアダプタのセット&#10;        val recyclerView = root.findViewById&lt;RecyclerView&gt;(R.id.recyclerViewRules)&#10;        val adapter = RuleAdapter { rule, isEnabled -&gt;&#10;            // 有効/無効変更時にDBへ反映&#10;            val updatedRule = rule.copy(enabled = isEnabled)&#10;            viewModel.updateRule(updatedRule)&#10;        }&#10;        recyclerView.adapter = adapter&#10;        recyclerView.layoutManager = androidx.recyclerview.widget.LinearLayoutManager(requireContext())&#10;&#10;        // ガントチャートViewのセットアップ&#10;        val ganttContainer = root.findViewById&lt;FrameLayout&gt;(R.id.ganttChartContainer)&#10;        ganttChartView = GanttChartView(requireContext())&#10;        ganttContainer.addView(ganttChartView, FrameLayout.LayoutParams(&#10;            FrameLayout.LayoutParams.MATCH_PARENT,&#10;            FrameLayout.LayoutParams.MATCH_PARENT&#10;        ))&#10;&#10;        // LiveData監視&#10;        viewModel.rules.observe(viewLifecycleOwner) { rules -&gt;&#10;            adapter.submitList(rules)&#10;            // ガントチャートにも反映&#10;            ganttChartView.setRules(rules)&#10;            // Geofenceリストの作成&#10;            val geofenceList = createGeofenceList(rules)&#10;            android.util.Log.d(&quot;DashboardFragment&quot;, &quot;Geofenceリスト作成: ${geofenceList.size}件&quot;)&#10;&#10;            // Geofence登録&#10;            if (geofenceList.isNotEmpty()) {&#10;                val geofencingRequest = createGeofencingRequest(geofenceList)&#10;                val pendingIntent = getGeofencePendingIntent()&#10;                geofencingClient.addGeofences(geofencingRequest, pendingIntent)&#10;                    .addOnSuccessListener {&#10;                        android.util.Log.d(&quot;DashboardFragment&quot;, &quot;Geofence登録成功&quot;)&#10;                    }&#10;                    .addOnFailureListener { e -&gt;&#10;                        android.util.Log.e(&quot;DashboardFragment&quot;, &quot;Geofence登録失敗: ${e.message}&quot;)&#10;                    }&#10;            }&#10;        }&#10;&#10;        // 初期表示時に現在の日付でルールを読み込む&#10;        val currentDate = LocalDate.now()&#10;        textSelectedDate.text = formatDate(selectedDate)&#10;        viewModel.loadRulesForDate(currentDate)&#10;&#10;        // 2. 日付選択ボタンのリスナー&#10;        buttonPickDate.setOnClickListener {&#10;            val picker = MaterialDatePicker.Builder.datePicker()&#10;                .setTitleText(&quot;日付を選択&quot;)&#10;                .setSelection(selectedDate)&#10;                .build()&#10;            picker.addOnPositiveButtonClickListener { dateMillis -&gt;&#10;                selectedDate = dateMillis&#10;                textSelectedDate.text = formatDate(selectedDate)&#10;                // 3. 日付選択後のViewModel呼び出し&#10;                val localDate = Instant.ofEpochMilli(selectedDate)&#10;                    .atZone(ZoneId.systemDefault())&#10;                    .toLocalDate()&#10;                viewModel.loadRulesForDate(localDate)&#10;            }&#10;            picker.show(parentFragmentManager, &quot;date_picker&quot;)&#10;        }&#10;&#10;        geofencingClient = LocationServices.getGeofencingClient(requireContext())&#10;&#10;        return root&#10;    }&#10;&#10;    private fun formatDate(millis: Long): String {&#10;        val sdf = SimpleDateFormat(&quot;yyyy/MM/dd&quot;, Locale.getDefault())&#10;        return sdf.format(Date(millis))&#10;    }&#10;&#10;    /**&#10;     * MainActivityから呼ばれる: ジオフェンスや位置情報イベントで有効になったルールIDを受け取りUIに反映&#10;     */&#10;    fun handleRuleSearchResult(ruleId: Long?) {&#10;        // 例: 現在有効なルールIDをViewModelやローカル変数にセットし、ガントチャートやリストをハイライト&#10;        // 必要に応じてadapterやViewModelに通知&#10;        // ここではログ出力のみ&#10;        android.util.Log.d(&quot;DashboardFragment&quot;, &quot;handleRuleSearchResult: ruleId=$ruleId&quot;)&#10;        // TODO: UIハイライトや状態更新処理をここに実装&#10;    }&#10;&#10;    /**&#10;     * 位置情報付きルールからGeofenceリストを作成&#10;     */&#10;    private fun createGeofenceList(rules: List&lt;com.example.smartmodeswitcher.data.Rule&gt;): List&lt;Geofence&gt; {&#10;        return rules.filter { it.latitude != null &amp;&amp; it.longitude != null &amp;&amp; it.radius != null }&#10;            .map { rule -&gt;&#10;                Geofence.Builder()&#10;                    .setRequestId(&quot;rule_${rule.id}&quot;)&#10;                    .setCircularRegion(&#10;                        rule.latitude!!,&#10;                        rule.longitude!!,&#10;                        rule.radius!!.toFloat()&#10;                    )&#10;                    .setExpirationDuration(Geofence.NEVER_EXPIRE)&#10;                    .setTransitionTypes(&#10;                        Geofence.GEOFENCE_TRANSITION_ENTER or Geofence.GEOFENCE_TRANSITION_EXIT&#10;                    )&#10;                    .build()&#10;            }&#10;    }&#10;&#10;    /**&#10;     * GeofenceリストからGeofencingRequestを作成&#10;     */&#10;    private fun createGeofencingRequest(geofenceList: List&lt;Geofence&gt;): GeofencingRequest {&#10;        return GeofencingRequest.Builder()&#10;            .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)&#10;            .apply {&#10;                geofenceList.forEach { addGeofence(it) }&#10;            }&#10;            .build()&#10;    }&#10;&#10;    private fun getGeofencePendingIntent(): PendingIntent {&#10;        val intent = Intent(requireContext(), GeofenceBroadcastReceiver::class.java)&#10;        return PendingIntent.getBroadcast(&#10;            requireContext(),&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>